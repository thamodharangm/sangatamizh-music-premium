generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  user
  admin
  moderator
}

enum SongStatus {
  uploaded
  processing
  ready
  failed
  blocked
}

enum ModerationStatus {
  pending
  approved
  rejected
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  passwordHash  String
  displayName   String
  role          UserRole  @default(user)
  avatarUrl     String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  songs         Song[]
  uploads       Upload[]
  playlists     Playlist[]
  sessions      Session[]
  blocked       BlockedUser? @relation("BlockedUser")
  blockedBy     BlockedUser[] @relation("BlockedBy")
}

model Session {
  id                String   @id @default(uuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshTokenHash  String
  userAgent         String?
  ipAddress         String?
  expiresAt         DateTime
  createdAt         DateTime @default(now())
}

model Song {
  id              String      @id @default(uuid())
  uploaderId      String?
  uploader        User?       @relation(fields: [uploaderId], references: [id])
  
  title           String
  artist          String
  album           String?
  genre           String?
  durationSeconds Int?
  coverImageKey   String?
  
  status          SongStatus  @default(uploaded)
  moderationStatus ModerationStatus @default(pending)
  isExplicit      Boolean     @default(false)
  rejectionReason String?
  audioFingerprint String?
  
  metadata        Json?       @default("{}")
  storageKeys     Json?       // { high: string, low: string, preview: string }
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  playlistSongs   PlaylistSong[]
  analytics       SongAnalytics[]
}

model Upload {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fileName     String
  originalSize BigInt
  mimeType     String?
  jobId        String?
  status       String   @default("pending")
  createdAt    DateTime @default(now())
}

model Playlist {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name          String
  description   String?
  isPublic      Boolean  @default(false)
  coverImageKey String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  songs         PlaylistSong[]
}

model PlaylistSong {
  playlistId String
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  songId     String
  song       Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  position   Int
  addedAt    DateTime @default(now())
  
  @@id([playlistId, songId])
}

model SongAnalytics {
  id        BigInt   @id @default(autoincrement())
  songId    String
  song      Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  userId    String?
  eventType String   // play, preview, download
  deviceInfo Json?
  timestamp DateTime @default(now())
}

model BlockedUser {
  userId      String   @id
  user        User     @relation("BlockedUser", fields: [userId], references: [id])
  blockedById String
  blockedBy   User     @relation("BlockedBy", fields: [blockedById], references: [id])
  reason      String?
  createdAt   DateTime @default(now())
}
